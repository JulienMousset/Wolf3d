./compass.c:	if (round(map->dir.x) == - 1 && round(map->dir.y) == 0 &&
./compass.c:			(x > per(map->mm_size, 33) && x < per(map->mm_size, 66)))
./compass.c:	if (round(map->dir.x) == - 1 && round(map->dir.y) == 1 &&
./compass.c:		(x > per(map->mm_size, 66)))
./compass.c:	if (round(map->dir.x) == - 1  && round(map->dir.y) == -1 &&
./compass.c:		(x < per(map->mm_size, 33)))
./compass.c:	if (round(map->dir.x) == 1 && round(map->dir.y) == 0 &&
./compass.c:			(x > per(map->mm_size, 33) && x < per(map->mm_size, 66)))
./compass.c:	if (round(map->dir.x) == 1 && round(map->dir.y) == 1 &&
./compass.c:		(x > per(map->mm_size, 66)))
./compass.c:	if (round(map->dir.x) == 1  && round(map->dir.y) == -1 &&
./compass.c:		(x < per(map->mm_size, 33)))
./compass.c:	if (round(map->dir.y) == - 1 && round(map->dir.x) == 0 &&
./compass.c:			(y > per(map->mm_size, 33) && y < per(map->mm_size, 66)))
./compass.c:	if (round(map->dir.y) == - 1 && round(map->dir.x) == 1 &&
./compass.c:		(y > per(map->mm_size, 66)))
./compass.c:	if (round(map->dir.y) == - 1  && round(map->dir.x) == -1 &&
./compass.c:		(y < per(map->mm_size, 33)))
./compass.c:	if (round(map->dir.y) == 1 && round(map->dir.x) == 0 &&
./compass.c:			(y > per(map->mm_size, 33) && y < per(map->mm_size, 66)))
./compass.c:	if (round(map->dir.y) == 1 && round(map->dir.x) == 1 &&
./compass.c:		(y > per(map->mm_size, 66)))
./compass.c:	if (round(map->dir.y) == 1  && round(map->dir.x) == -1 &&
./compass.c:		(y < per(map->mm_size, 33)))
./controls.c:		env->map->open_map = env->map->open_map ? 0 : 1;
./controls.c:		env->map->bool_tex = env->map->bool_tex ? 0 : 1;
./controls.c:	if (key == NUM_2 && env->map->item_map)
./controls.c:		env->map->opt = env->map->opt == 1 ? 2 : 1;
./controls.c:		set_mmap_values(env->map, env->map->opt);
./controls.c:		env->map->bool_spr = env->map->bool_spr ? 0 : 1;
./controls.c:		env->map->mm_color = env->map->mm_color ? 0 : 1;
./controls.c:		env->map->pick_coin++;
./controls.c:		env->map->pick_key++;
./controls.c:		env->map->pick_heart--;
./controls.c:		env->map->pick_heart++;
./controls.c:		env->map->look_up = 1;
./controls.c:		env->map->look_down = 1;
./controls.c:	if (env->map->pick_heart < 1)
./controls.c:		env->map->pick_heart = 1;
./controls.c:	if (env->map->pick_heart > env->map->container * 2)
./controls.c:		env->map->pick_heart = env->map->container * 2;
./controls.c:		env->map->up = 1;
./controls.c:		env->map->down = 1;
./controls.c:		env->map->left = 1;
./controls.c:		env->map->right = 1;
./controls.c:		env->map->strafe_left = 1;
./controls.c:		env->map->strafe_right = 1;
./controls.c:	if (key == KEY_SHIFT && env->map->item_heels)
./controls.c:		env->map->run = 1;
./controls.c:		env->map->up = 0;
./controls.c:		env->map->down = 0;
./controls.c:		env->map->left = 0;
./controls.c:		env->map->right = 0;
./controls.c:		env->map->strafe_left = 0;
./controls.c:		env->map->strafe_right = 0;
./controls.c:		env->map->run = 0;
./controls.c:		env->map->look_up = 0;
./controls.c:		env->map->look_down = 0;
./controls.c:	if (env->map->up == 1 || env->map->down == 1)
./controls.c:		up_or_down(env->map, env->map->board, env->map->dir);
./controls.c:	if (env->map->left == 1 || env->map->right == 1)
./controls.c:		env->map->mouse_left = 0;
./controls.c:		env->map->mouse_right = 0;
./controls.c:		left_or_right(env->map, env->map->rot_coef);
./controls.c:	if (env->map->strafe_left == 1 || env->map->strafe_right == 1)
./controls.c:		strafe(env->map, env->map->board, env->map->dir);
./controls.c:	if (env->map->open_map == 1)
./controls.c:		env->map->bool_menu = 1;
./controls.c:	else if (env->map->open_map == 0)
./controls.c:		env->map->bool_menu = 0;
./controls.c:	if (env->map->look_up == 1 || env->map->look_down == 1)
./controls.c:	if (env->map->mouse_left == 1 || env->map->mouse_right == 1)
./controls.c:		left_or_right(env->map, env->map->rot_coef / 1);
./controls.c:	if (env->map->camera_h == 5)
./controls.c:		env->map->look_up = 0;
./controls.c:		env->map->look_down = 0;
./controls.c:		env->map->camera_h = 0;
./controls.c:	env->map->camera_h++;
./controls.c:	if (env->map->camera_w == 5)
./controls.c:		env->map->mouse_left = 0;
./controls.c:		env->map->mouse_right = 0;
./controls.c:		env->map->camera_w = 0;
./controls.c:	env->map->camera_w++;
./controls_2.c:	ft_tabdel(env->map->board, env->map->nb_lines);
./controls_2.c:	ft_tabdel(env->map->board_cpy, env->map->nb_lines);
./controls_2.c:	if (map->look_up == 1)
./controls_2.c:		map->h2 += 25;
./controls_2.c:	if (map->look_down == 1)
./controls_2.c:		map->h2 -= 25;
./controls_2.c:	if (map->h2 > 960)
./controls_2.c:		map->h2 = 960;
./controls_2.c:	if (map->h2 < 0)
./controls_2.c:		map->h2 = 0;
./controls_2.c:	old_dir = map->dir.x;
./controls_2.c:	old_plane = map->plane.x;
./controls_2.c:	if (map->right == 1 || map->mouse_right == 1)
./controls_2.c:	map->dir.x = map->dir.x * cos(rot_speed) - map->dir.y * sin(rot_speed);
./controls_2.c:	map->dir.y = old_dir * sin(rot_speed) + map->dir.y * cos(rot_speed);
./controls_2.c:	map->plane.x = map->plane.x * cos(rot_speed) -
./controls_2.c:		map->plane.y * sin(rot_speed);
./controls_2.c:	map->plane.y = old_plane * sin(rot_speed) + map->plane.y * cos(rot_speed);
./controls_2.c:	move_speed = (map->run == 1) ? map->move_coef * 3 : map->move_coef;
./controls_2.c:	if (map->up == 1)
./controls_2.c:		add.x = (map->pos.x + dir.x * map->move_coef * SCALE_MS);
./controls_2.c:		add.y = (map->pos.y + dir.y * map->move_coef * SCALE_MS);
./controls_2.c:		if (is_walkable(map, board[add.x][(int)map->pos.y], add.x, map->pos.y))
./controls_2.c:			map->pos.x += dir.x * move_speed;
./controls_2.c:		if (is_walkable(map, board[(int)map->pos.x][add.y], map->pos.x, add.y))
./controls_2.c:			map->pos.y += dir.y * move_speed;
./controls_2.c:	if (map->down == 1)
./controls_2.c:		add.x = (map->pos.x - dir.x * map->move_coef * SCALE_MS);
./controls_2.c:		add.y = (map->pos.y - dir.y * map->move_coef * SCALE_MS);
./controls_2.c:		if (is_walkable(map, board[add.x][(int)map->pos.y], add.x, map->pos.y))
./controls_2.c:			map->pos.x -= dir.x * move_speed;
./controls_2.c:		if (is_walkable(map, board[(int)map->pos.x][add.y], map->pos.x, add.y))
./controls_2.c:			map->pos.y -= dir.y * move_speed;
./controls_2.c:	move_speed = (map->run == 1) ? map->move_coef * 2 : map->move_coef;
./controls_2.c:	if (map->strafe_left)
./controls_2.c:		add.x = (map->pos.x - dir.y * map->move_coef * SCALE_MS);
./controls_2.c:		add.y = (map->pos.y + dir.x * map->move_coef * SCALE_MS);
./controls_2.c:		if (is_walkable(map, board[add.x][(int)map->pos.y], add.x, map->pos.y))
./controls_2.c:			map->pos.x -= dir.y * move_speed;
./controls_2.c:		if (is_walkable(map, board[(int)map->pos.x][add.y], map->pos.x, add.y))
./controls_2.c:			map->pos.y += dir.x * move_speed;
./controls_2.c:	if (map->strafe_right)
./controls_2.c:		add.x = (map->pos.x + dir.y * map->move_coef * SCALE_MS);
./controls_2.c:		add.y = (map->pos.y - dir.x * map->move_coef * SCALE_MS);
./controls_2.c:		if (is_walkable(map, board[add.x][(int)map->pos.y], add.x, map->pos.y))
./controls_2.c:			map->pos.x += dir.y * move_speed;
./controls_2.c:		if (is_walkable(map, board[(int)map->pos.x][add.y], map->pos.x, add.y))
./controls_2.c:			map->pos.y -= dir.x * move_speed;
./create_threads.c:		t->ray_dir.x = map->dir.x + map->plane.x * t->camera_x;
./create_threads.c:		t->ray_dir.y = map->dir.y + map->plane.y * t->camera_x;
./create_threads.c:		t->block.x = map->pos.x;
./create_threads.c:		t->block.y = map->pos.y;
./create_threads.c:		map->z_buffer[x_start] = t->perp;
./create_threads.c:		t->id = map->board[t->block.x][t->block.y] - 1;
./create_threads.c:		if (map->bool_tex == 1)
./create_threads.c:	if (map->bool_spr == 1)
./create_threads.c:	map->item_map ? draw_minimap(env, env->map) : 0;
./create_threads.c:	//map->bool_menu ? menu(env) : 0;
./draw.c:	if (env->map->bool_tex == 1)
./draw.c:		d = y_start - env->map->h2 + th->line_height / 2;
./draw.c:	//map->color = add_smog(map->color, map->perp);
./draw.c:	//put_pixel(env, x, y_start, add_smog(map->color, abs(y_start - map->h2) * 0.005));
./draw.c:	if (env->map->bool_tex == 1)
./draw.c:			t->wall_x = env->map->pos.y + t->perp * t->ray_dir.y;
./draw.c:			t->wall_x = env->map->pos.x + t->perp * t->ray_dir.x;
./draw_sky.c:	y_start = H - map->h2;
./draw_sky.c:	while (i < map->h2)
./floor_and_ceiling.c:	if (map->ns_or_ew == 0 && map->ray_dir.x > 0)
./floor_and_ceiling.c:		map->floor.x = map->block.x;
./floor_and_ceiling.c:		map->floor.y = map->block.y + map->wall_x;
./floor_and_ceiling.c:	else if (map->ns_or_ew == 0 && map->ray_dir.x < 0)
./floor_and_ceiling.c:		map->floor.x = map->block.x + 1.0;
./floor_and_ceiling.c:		map->floor.y = map->block.y + map->wall_x;
./floor_and_ceiling.c:	else if (map->ns_or_ew == 1 && map->ray_dir.y > 0)
./floor_and_ceiling.c:		map->floor.x = map->block.x + map->wall_x;
./floor_and_ceiling.c:		map->floor.y = map->block.y;
./floor_and_ceiling.c:		map->floor.x = map->block.x + map->wall_x;
./floor_and_ceiling.c:		map->floor.y = map->block.y + 1.0;
./floor_and_ceiling.c:	map->dist_wall = map->perp;
./floor_and_ceiling.c:	map->dist_player = 0.0;
./floor_and_ceiling.c:	if (map->y_end < 0)
./floor_and_ceiling.c:		map->y_end = H;
./floor_and_ceiling.c:	y = map->y_end + 1;
./floor_and_ceiling.c:		map->dist_current = H / (2.0 * y - map->h2 * 2.0);
./floor_and_ceiling.c:		weight = (map->dist_current - map->dist_player) / (map->dist_wall - map->dist_player);
./floor_and_ceiling.c:		map->current_floor.x = weight * map->floor.x + (1.0 - weight) * map->pos.x;
./floor_and_ceiling.c:		map->current_floor.y = weight * map->floor.y + (1.0 - weight) * map->pos.y;
./floor_and_ceiling.c:		map->floor_tex.x = (int)(map->current_floor.x * TS) % TS;
./floor_and_ceiling.c:		map->floor_tex.y = (int)(map->current_floor.y * TS) % TS;
./floor_and_ceiling.c:		j = ((map->floor_tex.x * (env->t[9].bpp / 8)) + (map->floor_tex.y *
./floor_and_ceiling.c:		ft_memcpy(&map->color_str, &env->t[2].data_addr[j], sizeof(int));
./floor_and_ceiling.c:		map->color = (int)map->color_str;
./floor_and_ceiling.c:		//map->color = (map->color >> 1) & 8355711;
./floor_and_ceiling.c:		put_pixel(env, x, y, map->color);
./floor_and_ceiling.c:		ft_memcpy(&map->color_str, &env->t[1].data_addr[j], sizeof(int));
./floor_and_ceiling.c:		map->color = (int)map->color_str;
./floor_and_ceiling.c:		map->color = (map->color >> 1) & 8355711;
./floor_and_ceiling.c:		put_pixel(env, x, map->h2 * 2 - y, map->color);
./floor_and_ceiling.c:	if (map->ns_or_ew == 0 && map->ray_dir.x > 0)
./floor_and_ceiling.c:		map->floor.x = map->block.x;
./floor_and_ceiling.c:		map->floor.y = map->block.y + map->wall_x;
./floor_and_ceiling.c:	else if (map->ns_or_ew == 0 && map->ray_dir.x < 0)
./floor_and_ceiling.c:		map->floor.x = map->block.x + 1.0;
./floor_and_ceiling.c:		map->floor.y = map->block.y + map->wall_x;
./floor_and_ceiling.c:	else if (map->ns_or_ew == 1 && map->ray_dir.y > 0)
./floor_and_ceiling.c:		map->floor.x = map->block.x + map->wall_x;
./floor_and_ceiling.c:		map->floor.y = map->block.y;
./floor_and_ceiling.c:		map->floor.x = map->block.x + map->wall_x;
./floor_and_ceiling.c:		map->floor.y = map->block.y + 1.0;
./floor_and_ceiling.c:	map->dist_wall = map->perp;
./floor_and_ceiling.c:	map->dist_player = 0.0;
./floor_and_ceiling.c:	if (map->y_start < 0)
./floor_and_ceiling.c:		map->y_start = 0;
./floor_and_ceiling.c:	y = map->y_start;
./floor_and_ceiling.c:		map->dist_current = H / (2.0 * y - map->h2 * 2.0);
./floor_and_ceiling.c:		weight = (map->dist_current - map->dist_player) / (map->dist_wall - map->dist_player);
./floor_and_ceiling.c:		map->current_floor.x = weight * map->floor.x + (1.0 - weight) * map->pos.x;
./floor_and_ceiling.c:		map->current_floor.y = weight * map->floor.y + (1.0 - weight) * map->pos.y;
./floor_and_ceiling.c:		map->floor_tex.x = (int)(map->current_floor.x * TS) % TS;
./floor_and_ceiling.c:		map->floor_tex.y = (int)(map->current_floor.y * TS) % TS;
./floor_and_ceiling.c:		j = ((map->floor_tex.x * (env->t[2].bpp / 8)) + (map->floor_tex.y *
./floor_and_ceiling.c:		ft_memcpy(&map->color_str, &env->t[2].data_addr[j], sizeof(int));
./floor_and_ceiling.c:		map->color = (int)map->color_str;
./floor_and_ceiling.c:		map->color = (map->color >> 1) & 8355711;
./floor_and_ceiling.c:		put_pixel(env, x, y, map->color);
./gui.c:			ft_memcpy(&map->color_str, &env->t[id].data_addr[i], sizeof(int));
./gui.c:			map->color = (int)map->color_str;
./gui.c:			if (map->color != 0)
./gui.c:				put_pixel(env, margin.x + p.x, margin.y + p.y, map->color);
./gui.c:		c.x = map->gui_margin.x;
./gui.c:		c.y = map->gui_margin.y + TS * 0.8 * n;
./gui.c:		c.x = map->gui_margin.x;
./gui.c:		c.y = map->gui_margin.y;
./gui.c:	map->gui_margin.x = - TS / 2;
./gui.c:	while (++i <  map->pick_heart / 2)
./gui.c:		map->gui_margin.x += TS + 20;
./gui.c:	while (++i <  map->pick_heart % 2)
./gui.c:		map->gui_margin.x += TS + 20;
./gui.c:	while (++i <  map->container - (map->pick_heart / 2 + map->pick_heart % 2))
./gui.c:		map->gui_margin.x += TS + 20;
./gui.c:	map->gui_margin.x = - TS / 2;
./gui.c:	if (map->item_map)
./gui.c:	if (map->item_heels)
./gui.c:	if (map->item_poly)
./gui.c:	if (map->item_ipecac)
./gui.c:	if (map->item_godhead)
./gui.c:	if (map->item_heels && map->run)
./gui.c:	else if (map->item_heels)
./gui.c:	if (map->board[(int)map->pos.x][(int)map->pos.y] >= FIRST_SHOP &&
./gui.c:			map->board[(int)map->pos.x][(int)map->pos.y] <= LAST_SHOP &&
./gui.c:			map->pick_coin < 15)
./load_sprites.c:	while (i < map->nb_sprites)
./load_sprites.c:		if (map->s[i].x == x + 0.5 && map->s[i].y == y + 0.5)
./load_sprites.c:		map->pick_coin++;
./load_sprites.c:		map->pick_heart += 2;
./load_sprites.c:		map->pick_heart++;
./load_sprites.c:		map->pick_key++;
./load_sprites.c:		map->item_map = 1;
./load_sprites.c:		map->item_heels = 1;
./load_sprites.c:		map->pick_coin -= 15;
./load_sprites.c:			map->item_poly = 1;
./load_sprites.c:			map->item_ipecac = 1;
./load_sprites.c:			map->item_godhead = 1;
./load_sprites.c:			map->pick_coin = 99;
./load_sprites.c:			map->pick_key = 99;
./load_sprites.c:	if (map->pick_heart > map->container * 2)
./load_sprites.c:		map->pick_heart = map->container * 2;
./load_sprites.c:	if (map->pick_coin > 99)
./load_sprites.c:		map->pick_coin = 99;
./load_sprites.c:	if (map->pick_key > 99)
./load_sprites.c:		map->pick_key = 99;
./load_sprites.c:	if (!(new = (t_sprite *)malloc(sizeof(t_sprite) * map->nb_sprites - 1)))
./load_sprites.c:	while (i <  map->nb_sprites)
./load_sprites.c:		if (map->s[i].x == x + 0.5 && map->s[i].y == y + 0.5)
./load_sprites.c:			map->board[x][y] = 0;
./load_sprites.c:		new[i] = map->s[i + j];
./load_sprites.c:	map->nb_sprites--;
./load_sprites.c:	ft_memdel((void **)&(map->s));
./load_sprites.c:	map->s = new;
./load_sprites.c:	if (!(map->s = (t_sprite *)malloc(sizeof(t_sprite) * map->nb_sprites)))
./load_sprites.c:	if (!(map->spr_order = (int *)malloc(sizeof(int) * map->nb_sprites)))
./load_sprites.c:	if (!(map->spr_dist = (double *)malloc(sizeof(double) * map->nb_sprites)))
./load_sprites.c:	while (y < map->nb_lines)
./load_sprites.c:		while (x < map->nb_columns)
./load_sprites.c:			if (map->board[y][x] >= FIRST_SPR)
./load_sprites.c:	if (map->s != NULL)
./load_sprites.c:		ft_memdel((void **)&(map->s));
./load_sprites.c:	map->nb_sprites = nb_sprites(map);
./load_sprites.c:	while (y < map->nb_lines)
./load_sprites.c:		while (x < map->nb_columns)
./load_sprites.c:			if (map->board[y][x] >= FIRST_SPR)
./load_sprites.c:				map->s[i] = add_sprite(y, x, map->board[y][x]);
./main.c:	while (i < map->nb_lines)
./main.c:		ft_memdel((void **)&(map->board[i]));
./main.c:	ft_memdel((void **)&(map->board));
./minimap.c:	block = map->mm_block_size;
./minimap.c:	while (y < map->mm_size)
./minimap.c:		while (x < map->mm_size)
./minimap.c:			if (y > map->mm_size - block)
./minimap.c:			if (x > map->mm_size - block)
./minimap.c:			put_pixel(env, map->mm_start.x + x, map->mm_start.y + y, color);
./minimap.c:	block = map->mm_block_size;
./minimap.c:	while (y < map->mm_size)
./minimap.c:		while (x < map->mm_size)
./minimap.c:			if (y < block || y > map->mm_size - block ||
./minimap.c:					x < block || x > map->mm_size - block)
./minimap.c:				put_pixel(env, map->mm_start.x + x, map->mm_start.y + y, 0);
./minimap.c:				put_pixel(env, map->mm_start.x + x, map->mm_start.y + y, BOI);
./minimap.c:	if (map->mm_color)
./minimap.c:	xx *= map->mm_block_size;
./minimap.c:	yy *= map->mm_block_size;
./minimap.c:	coord.x = map->mm_center.x - map->mm_vis / 2 * map->mm_block_size;
./minimap.c:	coord.y = map->mm_center.y - map->mm_vis / 2 * map->mm_block_size;
./minimap.c:	while (y < map->mm_block_size)
./minimap.c:		while (x < map->mm_block_size)
./minimap.c:			if (((coord.x + x + xx < map->mm_end.x) &&
./minimap.c:						(coord.x + x + xx > map->mm_start.x)) &&
./minimap.c:					((coord.y + y + yy < map->mm_end.y) &&
./minimap.c:					 (coord.y + y + yy > map->mm_start.y)))
./minimap.c:	c.x = map->pos.y - map->mm_vis / 2;
./minimap.c:	c.y = map->pos.x - map->mm_vis / 2;
./minimap.c:	while (y < map->mm_vis)
./minimap.c:		while (x < map->mm_vis)
./minimap.c:			if((c.x + x >= 0) && (c.x + x < map->nb_columns) &&
./minimap.c:					(c.y + y >= 0) && (c.y + y < map->nb_lines) &&
./minimap.c:					map->board[c.y + y][c.x + x] &&
./minimap.c:					map->board[c.y + y][c.x + x] < 6)
./minimap.c:				put_n_pixel(env, x, y, map->board[c.y + y][c.x + x]);
./minimap.c:			if (c.x + x == (int)map->pos.y && c.y + y == (int)map->pos.x)
./misc.c:		if (i < W * env->map->h2)
./misc.c:	map->bool_print_price = 0;
./misc.c:	if (is_pickable(id) || is_shop(id, map->pick_coin))
./misc.c:	else if (id == ID_DOOR_C && map->pick_key)
./misc.c:		map->board[x][y] = ID_DOOR_O;
./misc.c:		map->pick_key--;
./misc.c:		map->bool_print_price = 1;
./misc.c:	ft_tabdel(map->board, map->nb_lines);
./misc.c:	map->board = ft_tabcpy(map->board_cpy, map->nb_lines, map->nb_columns);
./mouse.c:	if (x > env->map->mouse_pos.x)
./mouse.c:		env->map->mouse_right = 1;
./mouse.c:	else if (x < env->map->mouse_pos.x)
./mouse.c:		env->map->mouse_left = 1;
./mouse.c:	/*if (y > env->map->mouse_pos.y)
./mouse.c:		env->map->look_down = 1;
./mouse.c:	else if (y < env->map->mouse_pos.y)
./mouse.c:		env->map->look_up = 1;*/
./mouse.c:	env->map->mouse_pos.x = x;
./mouse.c:	env->map->mouse_pos.y = y;
./parsing.c:	while ((read = get_next_line(fd, &map->line)))
./parsing.c:		map->nb_columns = count_columns(map->line);
./parsing.c:		if ((previous != -1 && previous != map->nb_columns))
./parsing.c:		previous = map->nb_columns;
./parsing.c:		ft_memdel((void **)&(map->line));
./parsing.c:	if (!(read = get_next_line(fd, &map->line)))
./parsing.c:	ft_memdel((void **)&(map->line));
./parsing.c:	while ((read = get_next_line(fd, &map->line)))
./parsing.c:		if (map->line[1] == '\n' || !(check_map(map->line)))
./parsing.c:		ft_memdel((void **)&(map->line));
./parsing.c:	if (!(map->nb_lines = count_lines(map, file)))
./parsing.c:	if (!(map->board = (int **)malloc(sizeof(int *) * map->nb_lines)))
./parsing.c:	//ft_print_tab(map->board, map->nb_lines, map->nb_columns);
./parsing_2.c:	while (i < map->nb_lines)
./parsing_2.c:		while (j < map->nb_columns)
./parsing_2.c:			if ((i == 0 || j == 0 || i == map->nb_lines - 1
./parsing_2.c:			|| j == map->nb_columns - 1) && ((map->board[i][j] == 0) ||
./parsing_2.c:				map->board[i][j] > 9))
./parsing_2.c:	while ((read = get_next_line(fd, &map->line)))
./parsing_2.c:		map->tmp = ft_strsplit(map->line, ' ');
./parsing_2.c:		if (!(map->board[i] = (int *)malloc(sizeof(int) * map->nb_columns)))
./parsing_2.c:		while (map->tmp[j])
./parsing_2.c:			if (!ft_strcmp(map->tmp[j], "X"))
./parsing_2.c:				map->board[i][j] = 0;
./parsing_2.c:				map->pos_cpy = (t_complex) {.x = i, .y = j};
./parsing_2.c:			else if (ft_isdigit(map->tmp[j][0]))
./parsing_2.c:				map->board[i][j] = ft_atoi(map->tmp[j]);
./parsing_2.c:			else if (ft_islower(map->tmp[j][0]))
./parsing_2.c:				map->board[i][j] = map->tmp[j][0] - 87;
./parsing_2.c:		free_tmp_board(map->tmp);
./parsing_2.c:		ft_memdel((void **)&(map->line));
./ray_casting.c:		t->perp = (t->block.x - map->pos.x +
./ray_casting.c:		t->perp = (t->block.y - map->pos.y +
./ray_casting.c:	t->y_start = - t->line_height / 2 + map->h2;
./ray_casting.c:	t->y_end = t->line_height / 2 + map->h2;
./ray_casting.c:		t->hit = ((map->board[t->block.x][t->block.y] > 0) &&
./ray_casting.c:				(map->board[t->block.x][t->block.y] < FIRST_SPR)) ? 1 : 0;
./ray_casting.c:		t->side.x = (map->pos.x - t->block.x) * t->delta.x;
./ray_casting.c:		t->side.x = (t->block.x + 1.0 - map->pos.x) * t->delta.x;
./ray_casting.c:		t->side.y = (map->pos.y - t->block.y) * t->delta.y;
./ray_casting.c:		t->side.y = (t->block.y + 1.0 - map->pos.y) * t->delta.y;
./ray_casting.c:	if (map->boo == 0)
./ray_casting.c:		map->camera_x = 2 * x / (double)W - 1;
./ray_casting.c:		map->ray_dir.x = map->dir.x + map->plane.x * map->camera_x;
./ray_casting.c:		map->ray_dir.y = map->dir.y + map->plane.y * map->camera_x;
./ray_casting.c:		map->block.x = map->pos.x;
./ray_casting.c:		map->block.y = map->pos.y;
./ray_casting.c:		map->delta.x = fabs(1 / map->ray_dir.x);
./ray_casting.c:		map->delta.y = fabs(1 / map->ray_dir.y);
./ray_casting.c:		map->z_buffer[x] = map->perp;
./ray_casting.c:		map->id = map->board[map->block.x][map->block.y] - 1;
./ray_casting.c:		draw_line(env, env->map, x, env->map->y_start);
./ray_casting.c:		if (map->bool_tex == 1)
./ray_casting.c:	if (map->bool_spr == 1)
./ray_casting.c:	map->item_map ? draw_minimap(env, env->map) : 0;
./ray_casting.c:	map->bool_menu ? menu(env) : 0;
./sprites.c:	while (map->x_start < map->x_end)
./sprites.c:		map->tex.x = (int)(256 * (map->x_start - (-map->spr.width / 2 +
./sprites.c:						map->ssx)) * TS / map->spr.width) / 256;
./sprites.c:		if (map->transform.y > 0 && map->x_start > 0 && map->x_start < W &&
./sprites.c:				map->transform.y < map->z_buffer[map->x_start])
./sprites.c:			y = map->y_start;
./sprites.c:			while (y < map->y_end)
./sprites.c:				map->d = y - map->h2 + map->spr.height / 2;
./sprites.c:				map->tex.y = ((map->d * TS) / map->spr.height);
./sprites.c:				j = (map->tex.x * 4 + (map->tex.y * env->t[map->id].s_l));
./sprites.c:				ft_memcpy(&map->color_str, &env->t[map->id].data_addr[j],
./sprites.c:				map->color = (int)map->color_str;
./sprites.c:				if (map->color != 0)
./sprites.c:					put_pixel(env, map->x_start, y, map->color);
./sprites.c:		map->x_start++;
./sprites.c:	map->id = map->s[map->spr_order[i]].i;
./sprites.c:	map->spr.x = map->s[map->spr_order[i]].x - map->pos.x;
./sprites.c:	map->spr.y = map->s[map->spr_order[i]].y - map->pos.y;
./sprites.c:	map->inv_det = 1.0 /
./sprites.c:		(map->plane.x * map->dir.y - map->dir.x * map->plane.y);
./sprites.c:	map->transform.x = map->inv_det *
./sprites.c:		(map->dir.y * map->spr.x - map->dir.x * map->spr.y);
./sprites.c:	map->transform.y = map->inv_det *
./sprites.c:		(-map->plane.y * map->spr.x + map->plane.x * map->spr.y);
./sprites.c:	map->ssx = (int)((W / 2) * (1 + map->transform.x / map->transform.y));
./sprites.c:	map->spr.height = abs((int)(H / map->transform.y));
./sprites.c:	map->y_start = -map->spr.height / 2 + map->h2;
./sprites.c:	(map->y_start < 0) ? map->y_start = 0 : 0;
./sprites.c:	map->y_end = map->spr.height / 2 + map->h2;
./sprites.c:	(map->y_end >= H) ? map->y_end = H - 1 : 0;
./sprites.c:	map->spr.width = abs((int)(H / map->transform.y));
./sprites.c:	map->x_start = -map->spr.width / 2 + map->ssx;
./sprites.c:	(map->x_start < 0) ? map->x_start = 0 : 0;
./sprites.c:	map->x_end = map->spr.width / 2 + map->ssx;
./sprites.c:	(map->x_end >= W) ? map->x_end = W - 1 : 0;
./sprites.c:	while (i < map->nb_sprites)
./sprites.c:		map->spr_order[i] = i;
./sprites.c:		map->spr_dist[i] = (
./sprites.c:				(map->pos.x - map->s[i].x) *
./sprites.c:				(map->pos.x - map->s[i].x) +
./sprites.c:				(map->pos.y - map->s[i].y) *
./sprites.c:				(map->pos.y - map->s[i].y));
./sprites.c:	bubble_sort(map->spr_order, map->spr_dist, map->nb_sprites);
./sprites.c:	while (i < map->nb_sprites)
./text_gui.c:	c = get_cards(env->map->dir);
./text_gui.c:	c.e.x = env->map->mm_end.x - 15;
./text_gui.c:	c.e.y = env->map->mm_center.y - 4;
./text_gui.c:	c.w.x = env->map->mm_start.x + 5;
./text_gui.c:	c.w.y = env->map->mm_center.y - 5;
./text_gui.c:	c.n.x = env->map->mm_center.x - 5;
./text_gui.c:	c.n.y = env->map->mm_margin.y;
./text_gui.c:	c.s.x = env->map->mm_center.x - 1;
./text_gui.c:	c.s.y = env->map->mm_margin.y + env->map->mm_size - 22;
./text_gui.c:	env->map->gui_str = ft_itoa(env->map->pick_coin);
./text_gui.c:	mlx_string_put(mlx, win, c.x, c.y, M, env->map->gui_str);
./text_gui.c:	ft_memdel((void **)&(env->map->gui_str));
./text_gui.c:	env->map->gui_str = ft_itoa(env->map->pick_key);
./text_gui.c:	mlx_string_put(mlx, win, c.x, c.y += 40, M, env->map->gui_str);
./text_gui.c:	ft_memdel((void **)&(env->map->gui_str));
./text_gui.c:	//if (env->map->item_map)
./text_gui.c:	if (env->map->bool_print_price)
./text_gui.c:	if (env->map->board[(int)env->map->pos.x][(int)env->map->pos.y] >= FIRST_SHOP &&
./text_gui.c:			env->map->board[(int)env->map->pos.x][(int)env->map->pos.y] <= LAST_SHOP &&
./text_gui.c:			env->map->pick_coin < 15)
./wolf3d.c:	map->mm_size = per(W, 11) * opt; //size of the mmmap
./wolf3d.c:	map->mm_margin = (t_coord) {.x = per(W, 7), .y = per(H, 5)};
./wolf3d.c:	map->mm_vis = 16; // visualization of 40 blocks around
./wolf3d.c:	map->mm_block_size = (W / 64 / 3) * opt;  //size 4 -> 2x2 block
./wolf3d.c:	map->mm_start.x = W - map->mm_margin.x - map->mm_size;
./wolf3d.c:	map->mm_start.y = map->mm_margin.y;
./wolf3d.c:	map->mm_center.x =  W - map->mm_margin.x - map->mm_size / 2;
./wolf3d.c:	map->mm_center.y = map->mm_margin.y + map->mm_size / 2;
./wolf3d.c:	map->mm_end.x = W - map->mm_margin.x;
./wolf3d.c:	map->mm_end.y = map->mm_margin.y + map->mm_size;
./wolf3d.c:	map->mm_color = 0;
./wolf3d.c:	map->pos = map->pos_cpy;
./wolf3d.c:	map->dir = (t_complex) {.x = -1, .y = 0};
./wolf3d.c:	map->plane = (t_complex) {.x = 0, .y = 0.66};
./wolf3d.c:	map->move_coef = MOVE_SPEED;
./wolf3d.c:	map->rot_coef = ROT_SPEED;
./wolf3d.c:	map->run = 0;
./wolf3d.c:	map->opt = 1; //minimap size x1 or x2
./wolf3d.c:	map->h2 = H / 2;
./wolf3d.c:	map->walk = 0;
./wolf3d.c:	map->nb_sprites = 0;
./wolf3d.c:	map->bool_tex = 1;
./wolf3d.c:	map->bool_spr = 1;
./wolf3d.c:	map->bool_menu = 0;
./wolf3d.c:	map->bool_print_price = 0;
./wolf3d.c:	map->pick_coin = 0;
./wolf3d.c:	map->container = 3;
./wolf3d.c:	map->pick_heart = 1;
./wolf3d.c:	map->pick_key = 0;
./wolf3d.c:	map->item_map = 1;
./wolf3d.c:	map->item_heels = 1;
./wolf3d.c:	map->item_poly = 0;
./wolf3d.c:	map->item_ipecac = 0;
./wolf3d.c:	map->item_godhead = 0;
./wolf3d.c:	map->s = NULL;
./wolf3d.c:	map->spr_order = NULL;
./wolf3d.c:	map->spr_dist = NULL;
./wolf3d.c:	map->gui_scale = 2;
./wolf3d.c:	map->gui_counter = 2;
./wolf3d.c:	map->gui_size = TS * map->gui_scale;
./wolf3d.c:	map->gui_margin = (t_coord) {.x = - TS / 2, .y = - TS * 1.5};
./wolf3d.c:	map->mouse_pos = (t_coord) {.x = W / 1, .y = H / 1};
./wolf3d.c:	map->pos.x -= map->dir.x * MOVE_SPEED;
./wolf3d.c:	set_mmap_values(map, map->opt);
./wolf3d.c:	map->up = 0;
./wolf3d.c:	map->down = 0;
./wolf3d.c:	map->left = 0;
./wolf3d.c:	map->right = 0;
./wolf3d.c:	map->strafe_left = 0;
./wolf3d.c:	map->strafe_right = 0;
./wolf3d.c:	map->run_mode = 0;
./wolf3d.c:	map->open_map = 0;
./wolf3d.c:	map->look_up = 0;
./wolf3d.c:	map->look_down = 0;
./wolf3d.c:	map->mouse_left = 0;
./wolf3d.c:	map->mouse_right = 0;
./wolf3d.c:	map->camera_w = 0;
./wolf3d.c:	map->camera_h = 0;
./wolf3d.c:	map->prev = (t_coord) {.x = 0, .y = 0};
./wolf3d.c:	env->map->board_cpy = ft_tabcpy(env->map->board, env->map->nb_lines,
./wolf3d.c:			env->map->nb_columns);
